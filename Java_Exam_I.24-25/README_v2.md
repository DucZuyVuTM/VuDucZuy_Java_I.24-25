<p style="text-align: center; font-weight: bold;">
Список вопросов к экзамену по дисциплине<br>
Программирование на языке Джава<br>
зима 2024-2025 год
</p>

1. **Введение в Java. Основные характеристики языка, сферы применения, история создания. Экосистема языка JAVA. JDK, JRE, JVM.** 

   **-** Java — объектно-ориентированный язык программирования, созданный в 1995 году Sun Microsystems (ныне Oracle). Основные характеристики: переносимость, безопасность, многопоточность, автоматическое управление памятью.

   **-** **Сферы применения:** веб-разработка, мобильные приложения (Android), корпоративные системы, встраиваемые устройства.

   **-** **Экосистема Java:**

   * **JDK (Java Development Kit):** инструменты для разработки (компилятор, утилиты).

   * **JRE (Java Runtime Environment):** среда выполнения приложений.

   * **JVM (Java Virtual Machine):** выполняет байт-код, обеспечивая переносимость.

2. **Основные платформы Java. Java SE, Java EE, Java ME, их особенности и области применения.**

   **-** **Java SE (Standard Edition):** базовая платформа для разработки настольных и серверных приложений, включает стандартные библиотеки.

   **-** **Java EE (Enterprise Edition):** для создания масштабируемых корпоративных приложений, включает средства работы с базами данных, веб-серверами.

   **-** **Java ME (Micro Edition):** для разработки приложений на встроенных устройствах и мобильных платформах, оптимизирована для ограниченных ресурсов.

3. **Виртуальные машины и их роль в JAVA. Архитектура JVM. Основные компоненты: Class Loader, Execution Engine, Garbage Collector.**

   **-** VM обеспечивает переносимость, выполняя байт-код на любой поддерживаемой платформе.

   **-** **Архитектура JVM:**

   * **Class Loader:** загружает классы в память.

   * **Execution Engine:** интерпретирует или компилирует байт-код в машинный код (JIT-компиляция).

   * **Garbage Collector:** автоматически освобождает память, удаляя неиспользуемые объекты.
   Эти компоненты делают Java мощным и удобным для разработчиков.

4. **Компиляция Java-программ. Различия между JIT (Just-in-Time) и AOT (Ahead-of-Time) компиляцией. Преимущества и недостатки.** 

   **-** Компиляция в Java происходит в два этапа:

   1. Исходный код компилируется в байт-код (.class файлы).
   2. JVM исполняет байт-код.

   **-** **JIT (Just-in-Time):** компилирует байт-код в машинный код во время выполнения.

   * **Преимущества:** высокая производительность за счёт оптимизации часто выполняемого кода.

   * **Недостатки:** требует больше времени и памяти при старте.

   **-** **AOT (Ahead-of-Time):** компилирует байт-код в машинный код заранее.

   * **Преимущества:** быстрое время запуска.

   * **Недостатки:** меньше гибкости, сложнее оптимизация.

5. **Модель памяти в Java. Основные области памяти JVM: куча (Heap) и стек (Stack), их назначение и различия. Как распределяются объекты и примитивные данные в этих областях? Что такое Young Generation, Old Generation и Metaspace? Как работа сборщика мусора влияет на управление памятью?**

   **-** JVM делит память на:

   1. **Heap (куча):** хранение объектов. Делится на:
      * **Young Generation:** для новых объектов.
      * **Old Generation:** для объектов с долгим сроком жизни.
      * **Metaspace:** для метаданных классов.

   2. **Stack (стек):** хранение локальных переменных и вызовов методов.

   **-** **Распределение данных:**

   * Примитивы хранятся в стеке, если локальны, или в куче, если являются частью объекта.
   * Объекты размещаются в куче, ссылки на них — в стеке.

   **-** **Garbage Collector:** очищает неиспользуемую память, перераспределяя объекты между поколениями, что улучшает управление памятью.

6. **Основные парадигмы программирования в Java. Объектно-ориентированное, функциональное, многопоточное программирование.**

   **-** **Java** поддерживает три основные парадигмы:

   1. **Объектно-ориентированное программирование (ООП):**
      Java строится на концепциях классов и объектов, включая наследование, полиморфизм, инкапсуляцию и абстракцию.
   2. **Функциональное программирование:**
      С версии Java 8 введены лямбда-выражения и функциональные интерфейсы, которые упрощают функциональное программирование. 
   3. **Многопоточное программирование:**
      Java предоставляет мощную библиотеку для работы с потоками через java.lang.Thread и java.util.concurrent.

7. **Виртуальные машины и их роль в JAVA. Особенности стандартной [HotSpot JVM](https://www.google.com/search?newwindow=1&sca_esv=9d65c0a684302e9e&q=HotSpot+JVM&spell=1&sa=X&ved=2ahUKEwj_8ruYgIGKAxXEHBAIHSuHKFMQkeECKAB6BAgMEAE). GraalVM и другие сторонние виртуальные машины для Java. Основные преимущества и возможности сторонних виртуальных машин.**

   1. **HotSpot JVM:**
      1. Стандартная JVM от Oracle, используемая для выполнения Java-программ.
      2. Поддерживает JIT-компиляцию для повышения производительности.
   2. **GraalVM:**
      1. Универсальная виртуальная машина, поддерживающая Java, JavaScript, Python и другие языки.
      2. Предоставляет улучшенные возможности JIT и AOT-компиляции.
      3. Позволяет создавать нативные образы (native images), которые быстрее запускаются и используют меньше памяти.
   3. **Сторонние виртуальные машины:**
      1. **OpenJ9** (IBM): предназначена для экономии памяти и повышения скорости запуска.
      2. **Zulu JVM** (Azul Systems): нацелена на использование в корпоративных решениях.

   **-** **Пример работы JVM:**<br>
   JVM интерпретирует байт-код или компилирует его в машинный код с помощью JIT-компиляции, обеспечивая переносимость и производительность программы.

8. **Компиляция и запуск проекта на Java. Обеспечение переносимости кода на различные платформы. Понятие промежуточного байт-кода и его роль в переносимости программ. Чем отличаются методы компиляции JIT (Just-In-Time) и AOT (Ahead-of-Time), и как они влияют на производительность и переносимость?**

   **-** **Компиляция и переносимость:**

   * Java-программы компилируются в байт-код с помощью javac.
   * Байт-код выполняется на JVM, которая обеспечивает совместимость с различными платформами.

   **-** **Роль байт-кода:**

   * Байт-код — это промежуточный код, который может быть интерпретирован или компилирован JVM.
   * Обеспечивает независимость от операционной системы и архитектуры.

   **-** **JIT-компиляция:**

   * Выполняется во время работы программы.
   * Преобразует горячие участки байт-кода в машинный код для повышения производительности.

   **-** **AOT-компиляция:**

   * Преобразует байт-код в машинный код до выполнения.
   * Улучшает время запуска, но может снизить адаптивность программы к изменяющимся условиям.

9. **Современный инструментарий разработчика Java. Популярные IDE и их возможностей для написания, отладки и сборки кода. Основные системы сборки и их роль в управлении проектами на JAVA. Контроль версий с использованием Git и интеграция с платформами хостинга ИТ-проектов. Использование Docker и Kubernetes для контейнеризации и оркестрации приложений. Инструменты CI/CD для автоматизации сборки, тестирования и деплоя JAVA приложений.**

   **-** **Популярные IDE:**

   * **IntelliJ IDEA:** Автоматизация написания кода, встроенная поддержка популярных фреймворков (Spring, Hibernate).
   * **Eclipse:** Подходит для работы над большими проектами, поддержка множества плагинов.
   * **NetBeans:** Простота использования, автоматическое создание шаблонов кода.

   **-** **Системы сборки:**

   * **Maven:** Управление зависимостями, настройка сборки.
   * **Gradle:** Более гибкий и мощный по сравнению с Maven, поддерживает язык Groovy.

   **-** **Контроль версий:**

   * **Git:** Инструмент для отслеживания изменений в коде.
   * **GitHub, GitLab, Bitbucket:** Платформы для хостинга и управления проектами.

   **-** **Контейнеризация и оркестрация:**

   * **Docker:** Упрощает развертывание приложений через контейнеры.
   * **Kubernetes:** Позволяет управлять контейнерами на уровне кластера.

   **-** **Инструменты CI/CD:**

   * **Jenkins, GitHub Actions, GitLab CI/CD:** Автоматизация тестирования, сборки и деплоя приложений.

10. **Современные фреймворки для разработки на Java. Особенности Spring Framework. Основные возможности Hibernate. Основные причины использования данных фреймворков при разработке на JAVA.**

      **-** **Spring Framework:**

      * Модульная архитектура: Spring Core, Spring MVC, Spring Boot.
      * Упрощение разработки через Dependency Injection (DI).
      * Spring Boot: минимизация настройки для создания REST API.

      **-** **Hibernate:**

      * Обеспечивает ORM (Object-Relational Mapping).
      * Упрощает работу с базами данных.
      * Автоматическое управление транзакциями и кешированием.

      **-** **Причины использования:**

      * Повышение скорости разработки.
      * Уменьшение объема шаблонного кода.
      * Интеграция с широким спектром технологий.

11. **Объектная модель Java. Основные принципы объектной модели в Java: классы, объекты, интерфейсы, наследование и инкапсуляция. Класс Object и методы, которые он предоставляет.**

      **-** **Принципы объектной модели:**

      * **Классы и объекты:** Класс определяет свойства и поведение, а объект является экземпляром класса.
      * **Наследование:** Позволяет одному классу использовать свойства другого.
      * **Инкапсуляция:** Скрытие деталей реализации через private и предоставление доступа через public методы.

      **-** **Класс Object:**

      * Является суперклассом всех классов в Java.
      * Основные методы: toString(), equals(), hashCode(), clone()

12. **Пакеты в Java. Основное предназначение. Структура, организация, использование в программировании (импорт пакетов).**

      **-** **Назначение пакетов:**

      * Организация классов в логические группы.
      * Предотвращение конфликтов имен.
      * Упрощение доступа к библиотекам.

      **-** **Структура пакетов:**

      * Пакеты определяют структуру директорий в проекте.

      **-** **Использование:**

      * Импорт стандартных или пользовательских пакетов с помощью import.
      * Организация классов в пакеты через директиву package.

13. **Синтаксис и лексика Java. Основные элементы лексики языка: ключевые слова, идентификаторы, литералы, комментарии, операторы и разделители. Правила именования идентификаторов. Соглашения по оформлению кода.**

      **-** **Элементы лексики:**

      * **Ключевые слова:** Зарезервированные слова языка (например, class, if, else, public, static).
      * **Идентификаторы:** Имена переменных, методов, классов (например, myVariable, doSomething).
      * **Литералы:** Конкретные значения (например, 123, "Hello").
      * **Комментарии:** Однострочные (//) и многострочные (/\* ... \*/).
      * **Операторы:** Арифметические, логические, присваивания (+, -, &&, =).
      * **Разделители:** Скобки, точки с запятой, запятые ({}, ;, ,).

      **-** **Правила именования идентификаторов:**

      * Должны начинаться с буквы, $ или \_, не могут начинаться с цифры.
      * Не должны совпадать с ключевыми словами.
      * Регистр имеет значение (например, myVariable и MyVariable — разные идентификаторы).

      **-** **Соглашения по оформлению:**

      * Имена классов пишутся в PascalCase (например, MyClass).
      * Имена переменных и методов — в camelCase (например, myVariable, doSomething).
      * Константы пишутся в UPPER\_CASE (например, PI).

14. **Типы данных в Java. Примитивные типы данных, объявление и присваивание переменных. Отличия примитивных типов данных от ссылочных.**
      1. **Примитивные типы данных:**
         1. **Целые числа:** byte, short, int, long.
         2. **Числа с плавающей точкой:** float, double.
         3. **Логический тип:** boolean (значения: true, false).
         4. **Символы:** char.
      2. **Отличия примитивных типов от ссылочных:**
         1. Примитивные типы хранят значение непосредственно.
         2. Ссылочные типы содержат ссылку на объект в памяти.
         3. Примитивные типы не могут быть null.

15. **Типы данных в Java. Ссылочные типы данных, объявление и присваивание переменных. Отличия ссылочных типов данных от примитивных. Роль классов-оберток (Wrapper Classes) для работы с примитивами.**

      **-** **Ссылочные типы данных:**

      * Классы, интерфейсы, массивы, строки.
      * Пример: String, Integer, Double.

      **-** **Отличия ссылочных типов от примитивных:**

      * Ссылочные типы могут быть null.
      * Объекты ссылочных типов содержат методы для работы с данными.

      **-** **Классы-обертки (Wrapper Classes):**

      * Преобразуют примитивные типы в объекты.
      * Удобны для работы с коллекциями и Generics.

      ```java
      int primitive = 5;

      Integer wrapped = Integer.valueOf(primitive); // Автоупаковка

      int unwrapped = wrapped; // Автораспаковка
      ```

16. **Константы в Java. Понятие констант и их объявление с использованием ключевого слова final. Основные правила и соглашения по именованию констант. Примеры создания констант для примитивных типов данных и строк. Как константы помогают обеспечить неизменность данных и улучшают читаемость кода?**

      **-** Константы — неизменяемые значения, объявляемые с использованием final. Соглашения: имена в UPPER\_CASE через \_. 
      
      Примеры:

      ```java
      final int MAX_AGE = 100;  

      final String GREETING = "Hello";
      ```

      **-** Константы защищают данные от изменений и повышают читаемость. Они используются для обозначения фиксированных параметров (e.g., математических значений, настроек).

17. **Ключевое слово var в Java. Особенности использования var для объявления локальных переменных. Как происходит неявное выведение типа переменной компилятором? Ограничения на использование var: недопустимость для полей класса, параметров методов и возвращаемых типов.**

      **-** var вводит неявное выведение типа для локальных переменных. Тип определяется компилятором из присваиваемого значения:

      ```java
      var name = "John"; // String  

      var count = 10;    // int
      ```

      **-** Ограничения: нельзя использовать для полей класса, параметров методов, возвращаемых типов. Удобно для улучшения читаемости при сложных типах.

18. **Соглашения по оформлению кода Java. Java Code Conventions и её значение для совместной работы.**

      **-** **Java Code Conventions** — это набор рекомендаций по написанию кода, разработанный Oracle. Их цель — улучшение читаемости и упрощение совместной работы над проектом.

      **-** **Основные аспекты:**

      * **Именование:**
         - Классы: PascalCase (например, MyClass).
         - Методы и переменные: camelCase (например, calculateSum).
         - Константы: UPPER\_CASE (например, MAX\_VALUE).
      * **Отступы:** Использование 4 пробелов для отступов.
      * **Максимальная длина строки:** 80 или 120 символов.
      * **Форматирование скобок:** Открывающая скобка на той же строке, что и объявление:

      **-** **Значение:**

      * Облегчение совместной работы над кодом в команде.
      * Упрощение чтения и поддержки кода.
      * Унифицированный стиль, независимый от разработчика.

19. **Класс и экземпляры класса. Что такое класс в Java и как происходит создание объектов (инстанцирование) с использованием ключевого слова new? Примеры создания и использования экземпляров класса.**

      **-** Класс — шаблон для создания объектов. Экземпляры класса (англ. instance) — это описания конкретного объекта в памяти. Создание объекта (инстанцирование):

      ```java
      class Person {
         String name;
         int age;
      }

      Person person = new Person();

      person.name = "Alice";
      person.age = 25;
      ```

      **-** Экземпляры класса содержат состояние (поля) и поведение (методы), заданное в классе.

20. **Записи (Records) в Java. Какие возможности они предоставляют и в чем их отличие от обычных классов? Примеры использования записей.**

      **-** **Записи (Records):**

      * Представлены в Java 14 (в виде preview) и окончательно введены в Java 16.
      * Предоставляют компактный способ создания неизменяемых классов для хранения данных.

      **-** **Особенности:**

      * Автоматически генерируют конструктор, геттеры, методы equals, hashCode и toString.
      * Не поддерживают мутабельные поля.

      **-** **Пример записи:**

      ```java
      public record Point(int x, int y) {}
      ```

      **-** **Использование:**

      ```java
      Point point = new Point(3, 4);

      System.out.println(point.x()); // 3
      System.out.println(point.y()); // 4
      System.out.println(point);     // Point[x=3, y=4]
      ```

      **-** **Отличия от обычных классов:**

      * **Меньше кода:** Не требуется писать конструкторы и методы.
      * **Иммутабельность:** Поля неизменяемы после инициализации.
      * **Применение:** Используются для представления "структур данных" без дополнительной логики.

21. **Запечатанные (Sealed) классы. Как они ограничивают наследование и для чего используются?**

      **-** Запечатанные классы (sealed) ограничивают список классов, которые могут их наследовать. Используются для повышения безопасности и контроля структуры кода.
      
      Пример:

      ```java
      public sealed class Shape permits Circle, Rectangle {}

      public final class Circle extends Shape {}

      public final class Rectangle extends Shape {}
      ```

      **-** Это позволяет явно задавать возможные типы наследников, упрощая поддержку и исключая несанкционированное расширение.

22. **Инкапсуляция в Java. Понятие инкапсуляции как механизма защиты данных и управления доступом к ним. Реализация инкапсуляции с использованием модификаторов доступа (private, protected, public, package-private). Роль геттеров и сеттеров в обеспечении контроля за изменением данных объекта. Примеры нарушения инкапсуляции и способы предотвращения этих ошибок.**

      **-** Инкапсуляция защищает данные и управляет доступом к ним через модификаторы доступа:

      * **private:** доступ только внутри класса.
      * **protected:** доступ в пакете и наследниках.
      * **public:** доступ везде.
      * **package-private (по умолчанию):** доступ в пакете.

      **-** Геттеры и сеттеры контролируют доступ к полям:

      ```java
      private int age;

      public int getAge() {
         return age;
      }

      public void setAge(int age) {
         if (age > 0) this.age = age;
      }
      ```

      **-** **Нарушение:** прямой доступ к полям. **Решение:** сделать их private.

23. **Модификаторы доступа. Какие уровни доступа существуют в Java? Как модификаторы доступа используются для контроля видимости классов, полей и методов?**

      **-** Java поддерживает 4 уровня доступа:

      1. **private:** доступен только внутри класса.
      2. **default (package-private):** доступ внутри пакета.
      3. **protected:** доступен в пакете и наследниках.
      4. **public:** доступ без ограничений.

      **-** Используются для контроля видимости классов, полей и методов, чтобы ограничивать или разрешать взаимодействие с ними из разных частей программы.

24. **Модификатор final. Применение final к переменным, методам и классам. Как он предотвращает изменения данных, поведение методов и наследование?** 

      **-** final предотвращает изменения:

      * **Переменные:** становятся константами (их значение нельзя изменить после инициализации).

      ```java
      final int MAX_VALUE = 100;
      ```

      * **Методы:** нельзя переопределить в подклассах.

      ```java
      public final void display() {}
      ```

      - **Классы:** запрещается наследование.

      ```java
      public final class Constants {}
      ```

      **-** final гарантирует неизменяемость данных, поведения или структуры класса.

25. **Конструкторы в Java. Понятие конструктора и его роль в создании объектов. Различия между конструктором и методом. Типы конструкторов. Как реализовать перегрузку конструкторов?** 

      **-** **Конструктор** — специальный метод для инициализации объекта, вызывается при создании через new. Отличия от метода: не имеет возвращаемого типа и имя совпадает с именем класса.

      **-** **Типы:**

      * **По умолчанию:** создаётся компилятором, если не определён явно.
      * **Пользовательский:** задаёт инициализацию.
      * **Перегрузка:** создаются несколько конструкторов с разными параметрами.

      ```java
      public class Person {
         public Person() {}

         public Person(String name) {
            this.name = name;
         }
      }
      ```

26. **Конструкторы в Java. Понятие конструктора и его роль в создании объектов. Использование ключевого слова this для вызова одного конструктора из другого. Особенности работы конструкторов в наследовании, вызов конструктора родительского класса через super.**

      **-** Ключевое слово this используется для вызова конструктора текущего класса:

      ```java
      public Person(String name) {
         this(name, 0); // вызов другого конструктора
      }

      public Person(String name, int age) { ... }
      ```

      **-** **Наследование:** конструктор подкласса всегда вызывает конструктор родителя через super:

      ```java
      public class Employee extends Person {
         public Employee(String name, int age) {
            super(name, age); // вызов конструктора родителя
         }
      }
      ```

      **-** Если super не указан, вызывается конструктор по умолчанию.

27. **Блоки инициализации. Виды блоков инициализации: статические и нестатические. Их роль в подготовке объектов и классов. Примеры использования блоков для сокращения повторяющегося кода.**

      **-** Блоки инициализации используются для подготовки объектов и классов:

      1. **Статические:** выполняются один раз при загрузке класса.

      ```java
      static {
         System.out.println("Static block executed");
      }
      ```

      2. **Нестатические:** выполняются при создании каждого объекта.

      ```java
      {
         System.out.println("Instance block executed");
      }
      ```

      **-** Они помогают сокращать повторяющийся код, например, при сложной инициализации.

28. **Статические блоки инициализации. Примеры и использование статических блоков для выполнения кода при загрузке класса. Их роль в инициализации общих данных.**

      **-** Статические блоки выполняются при загрузке класса JVM. Используются для инициализации общих данных:

      ```java
      class Config {
         static String dbUrl;

         static {
            dbUrl = "jdbc:mysql://localhost:3306/db";
            System.out.println("Static block executed");
         }
      }
      ```

      **-** Позволяют выполнять операции один раз, такие как загрузка настроек или инициализация статических переменных.

29. **Модификатор static. Особенности использования static для полей, методов и блоков. Различия между статическими и нестатическими членами класса. Примеры применения для создания общих ресурсов.**

      **-** **static** используется для:

      * **Полей:** принадлежат классу, а не объекту.
      * **Методов:** вызываются без создания объекта.
      * **Блоков:** выполняются при загрузке класса.

      **-** **Различия:** статические члены разделяются между всеми экземплярами, а нестатические принадлежат конкретному объекту.

      Пример:

      ```java
      class Example {
         static int count = 0;
         int id;

         Example() {
            id = ++count;
         }
      }
      ```

      **-** Используется для создания общих ресурсов (e.g., счетчиков, констант).

30. **Ключевое слово this. Использование this для доступа к полям и методам объекта, вызова других конструкторов и передачи текущего объекта. Примеры решения конфликтов имен с помощью this.**

      **-** **this** используется для:

      1. **Доступа к полям и методам объекта:**

      ```java
      public void setName(String name) {
         this.name = name; // решает конфликт имен
      }
      ```

      2. **Вызова конструктора текущего класса:**

      ```java
      public Person(String name) {
         this(name, 0);
      }
      ```

      3. **Передачи текущего объекта:**
      ```java
      someMethod(this);
      ```

      **-** this помогает избежать конфликтов имен и однозначно ссылаться на текущий объект.

31. **Концепция неизменяемых классов. Что делает класс неизменяемым? Использование final для предотвращения изменений. Примеры создания неизменяемых объектов.**

      **-** Неизменяемый класс не позволяет изменять своё состояние после создания. Для этого:

      1. Объявите класс final.
      2. Сделайте все поля private и final.
      3. Не предоставляйте сеттеры, только геттеры.
      4. Возвращайте копии изменяемых объектов.

      Пример:

      ```java
      final class ImmutableClass {
         private final String name;
         private final List<String> items; // Mutable object

         public ImmutableClass(String name, List<String> items) {
            this.name = name;
            this.items = new ArrayList<>(items); // Save a copy instead of the original reference
         }

         public String getName() {
            return name;
         }

         public List<String> getItems() {
            return new ArrayList<>(items); // Return a copy of the list
         }
      }
      ```

      **-** Неизменяемые классы удобны для многопоточного программирования.

32. **Создание объектов. Отличие фабричных методов от стандартного создания объектов с использованием new. Примеры использования фабричных методов.**

      **-** **new:** стандартный способ создания объектов.

      **-** **Фабричные методы:** предоставляют создание через статический метод, скрывая детали реализации.

      Пример:

      ```java
      class Example {
         private Example() {}

         public static Example createInstance() {
            return new Example();
         }
      }

      Example obj = Example.createInstance();
      ```

      **-** Фабричные методы обеспечивают гибкость, контроль над созданием объектов и использование шаблонов (e.g., Singleton).

33. **Рефлексия в Java. Возможности рефлексии для создания объектов и вызова методов во время выполнения. Примеры использования рефлексии для создания объектов.**

      **-** Рефлексия позволяет исследовать классы, создавать объекты и вызывать методы во время выполнения.
      
      Пример:

      ```java
      Class<?> cls = Class.forName("Example");

      Object obj = cls.getDeclaredConstructor().newInstance();

      Method method = cls.getMethod("someMethod");

      method.invoke(obj);
      ```

      **-** Рефлексия полезна для динамических задач, таких как создание объектов по имени класса, но снижает производительность и безопасность.

34. **Жизненный цикл объектов в JAVA. Роль сборщика мусора в управлении памятью. Примеры оптимизации работы объектов в Java.**

      **-** Объект создаётся через new и живёт, пока на него есть ссылки. Когда ссылки исчезают, объект становится кандидатом для удаления сборщиком мусора (Garbage Collector).

      **-** Пример оптимизации:

      * Своевременно зануляйте ссылки (obj = null) для старых объектов.
      * Избегайте утечек памяти, например, в статических коллекциях.
         
         Garbage Collector автоматизирует управление памятью, предотвращая её ручное освобождение.

35. **Инициализация переменных в JAVA. Способы инициализации переменных: по умолчанию, в конструкторах, через блоки инициализации. Примеры применения.**

      **-** **Способы инициализации:**

      1. **По умолчанию:** переменные экземпляра получают значения (0, null, false).
      1. **В конструкторах:** обеспечивает настройку объекта.

      ```java
      public MyClass(int value) {
         this.value = value;
      }
      ```

      3. **Через блоки инициализации:** общий код для всех конструкторов.

      ```java
      {
         value = 10;
      }
      ```

      **-** Используйте конструкторы для гибкости и блоки для повторного кода.

36. **Математические функции. Класс Math в Java и его методы для выполнения вычислений. Примеры использования тригонометрических и экспоненциальных функций в задачах. Нужно ли создавать объект класса Math для использования математических методов.**

      **-** Класс Math содержит статические методы для вычислений.

      **Примеры:**

      * Тригонометрия: Math.sin(angle), Math.cos(angle).
      * Экспоненты: Math.exp(x), Math.log(x).
      * Округление: Math.round(value).

      ```java
      double result = Math.pow(2, 3); // 8.0
      ```

      **-** Создавать объект класса Math не нужно, так как методы статические.

37. **Абстракция и инкапсуляция класса. Понятие абстракции как отделения реализации класса от его использования. Как эти принципы улучшают структурирование кода и его модульность?**

      **-** **Абстракция:** отделяет интерфейс класса от его реализации, скрывая детали. 
      
      Пример: использование интерфейсов и абстрактных классов.

      **-** **Инкапсуляция:** защита данных с помощью модификаторов доступа.

      **-** Эти принципы делают код более читаемым, модульным и легко поддерживаемым. Например, логика объекта может измениться, не влияя на его интерфейс.

38. **Отношения между классами. Основные виды отношений между классами: ассоциация, агрегация, композиция, наследование.**

      **-** Отношение между классами — способ, которым классы взаимодействуют, соединяются или зависят друг от друга, чтобы представить логику и структуру программы.

      **-** **Виды отношений:**

      1. **Ассоциация:** простой связи между объектами.
      2. **Агрегация:** "слабая" связь (объекты существуют независимо).
      3. **Композиция:** "сильная" связь (жизненный цикл объекта зависит от другого).
      4. **Наследование:** отношение "is-a", указывает на общий базовый класс.

39. **Ассоциация. Понятие ассоциации как бинарного отношения между классами. Примеры реализации ассоциации в Java. Как ассоциация помогает моделировать взаимодействие объектов?**

      **-** Ассоциация — связь между объектами разных классов, где они взаимодействуют друг с другом, оставаясь независимыми.

      **Пример:**

      ```java
      class Student {
         private Teacher teacher;
      }

      class Teacher {
         private List<Student> students;
      }
      ```

      **-** Ассоциация помогает моделировать связи, такие как "учитель-студент", и упрощает представление реальных взаимодействий.

40. **Агрегация и композиция. Понятия агрегации и композиции, их различия. Как они отражают отношения «has-a» между объектами? Примеры реализации агрегации и композиции в проектировании классов.**

      **-** **Агрегация** — это слабая связь, когда один объект содержит другие, но они могут существовать независимо. Это отношение "has-a".
      
      **Пример:**

      ```java
      class Department {
         private List<Employee> employees;

         public Department() {
            this.employees = new ArrayList<>();
         }

         public void addEmployee(Employee employee) {
            employees.add(employee);
            // Employee can exist without the Department.
         }
      } 
      ```

      **-** **Композиция** — сильная связь, когда жизнь одного объекта зависит от другого. Уничтожение объекта приводит к уничтожению связанных объектов.

      **Пример:**

      ```java
      class House {
         private Room room;

         public House() {
            this.rooms = new ArrayList<>();
         }

         public void addRoom(String roomName) {
            Room room = new Room(roomName);
            rooms.add(room);
            // Room cannot exist without the House.
         }
      }
      ```

      **-** Агрегация предполагает более гибкое разделение, в то время как композиция устанавливает строгую зависимость.

41. **Обработка примитивных типов как объектных. Использование классов-оберток для работы с примитивными типами как с объектами. Примеры преобразования примитивных типов в объекты и обратно.** 

      **-** Использование классов-оберток позволяет работать с примитивными типами как с объектами.
      
      Примеры:

      * Преобразование примитивного типа в объект:

      ```java
      Integer i = Integer.valueOf(10);
      ```

      * Преобразование объекта в примитив:

      ```java
      int x = i.intValue();
      ```

      **-** Это полезно, когда требуется использование коллекций, которые работают только с объектами.

42. **Классы-обертки. Основные возможности классов-оберток: Integer, Double, Boolean и других. Методы для преобразования значений и сравнения объектов. Примеры использования методов parseInt, valueOf и compareTo.**

      **-** Основные классы-обертки:

      * **Integer, Double, Boolean** и другие предоставляют методы для преобразования значений.
      * Примеры:
         * Integer.parseInt("10") — строку в число.
         * Integer.valueOf(10) — создание объекта.
         * Integer.compareTo() — сравнение объектов.

      ```java
      int x = Integer.parseInt("20");

      Integer obj = Integer.valueOf(100);

      System.out.println(obj.compareTo(50));  // 1
      ```

      **-** Классы-обертки обеспечивают удобный способ работы с примитивами в коллекциях и других объектах.

43. **Автоматическое преобразование. Что такое автоупаковка (autoboxing) и автораспаковка (unboxing) в Java? Как они автоматически преобразуют значения примитивных типов в объекты и обратно? Примеры использования.**

      **-** **Автоупаковка (autoboxing)** — автоматическое преобразование примитивных типов в объекты.

      ```java
      Integer x = 10;  // автоупаковка
      ```

      **-** **Автораспаковка (unboxing)** — автоматическое преобразование объектов обратно в примитивы.

      ```java
      int y = x;  // автораспаковка
      ```

      **-** Автоупаковка и автораспаковка упрощают работу с примитивами и обертками, снижая необходимость явных преобразований.

44. **Класс String. Понятие неизменяемости(иммутабельности) строк в Java. Как создаются объекты типа String? Примеры работы с методами создания, сравнения и модификации строк.**

      **-** **Иммутабельность:** объекты String неизменяемы, их значение нельзя изменить после создания. Изменения создают новый объект.

      **-** **Создание строк:**

      1. Литералы: String s = "Hello"; (используется пул строк).
      2. Через new: String s = new String("Hello");.

      **-** **Примеры методов:**

      * Создание:

      ```java
      String s1 = "Hello";

      String s2 = new String("World");
      ```

      * Сравнение:

      ```java
      s1.equals(s2); // сравнение значений

      s1 == s2;      // сравнение ссылок
      ```

      * Модификация:

      ```java
      String s3 = s1.concat(" World"); // Создает новую строку
      ```

45. **Строки в JAVA. Замена и разделение строк. Методы класса String для замены символов и разделения строк. Примеры работы с методами replace и split.**

      **-** **Методы замены и разделения:**

      1. replace: заменяет символы или подстроки:

      ```java
      String s = "Java";

      System.out.println(s.replace('a', 'o')); // Jovo
      ```

      2. split: разделяет строку на массив по разделителю:

      ```java
      String text = "apple,banana,grape";

      String[] fruits = text.split(",");

      for (String fruit : fruits) System.out.println(fruit);
      ```

      **-** Эти методы полезны для обработки текстов и данных.

46. **Строки в JAVA. Преобразования между строками и массивами. Как преобразовать строку в массив символов и наоборот? Примеры использования методов toCharArray и valueOf.**

      1. **Строка в массив символов:**

      ```java
      String str = "Hello";

      char[] chars = str.toCharArray(); // {'H', 'e', 'l', 'l', 'o'}
      ```

      2. **Массив символов в строку:**

      ```java
      char[] chars = {'H', 'e', 'l', 'l', 'o'};

      String str = String.valueOf(chars); // "Hello"
      ```

      **-** Эти методы полезны для работы с символами строки, включая их анализ и модификацию.

47. **Строки в JAVA. Класс StringBuilder и StringBuffer. Понятие изменяемых строк. Основные отличия между StringBuilder и StringBuffer. Примеры их использования. Влияние классов StringBuilder и StringBuffer на типобезопасность.**

      **-** **Изменяемые строки:** StringBuilder и StringBuffer позволяют изменять строки без создания новых объектов.

      **-** **Различия:**

      * StringBuilder: быстрее, не синхронизирован.
      * StringBuffer: медленнее, синхронизирован, безопасен для многопоточности.

      **Примеры:**

      ```java
      StringBuilder sb = new StringBuilder("Hello");
      StringBuffer sbff = new StringBuffer("Hello World");

      sb.append(" World");
      sbff.insert(5, " Java");

      System.out.println(sb);   // Hello World
      System.out.println(sbff); // Hello Java World
      ```

      **-** Оба класса безопасны для типа, так как работают с символами и строками.

48. **Строки в JAVA. Преобразование символов и чисел в строки. Какие методы используются для преобразования чисел, символов и объектов в строки? Примеры работы с методами String.valueOf() и toString().**

      **-** **Методы преобразования:**

      1. String.valueOf:

      ```java
      int num = 10;

      String str = String.valueOf(num); // "10"
      ```

      2. toString: вызывается у объектов:

      ```java
      Integer obj = 20;

      String str = obj.toString(); // "20"
      ```

      **-** **Отличие:** valueOf работает с примитивами и объектами, toString — только с объектами.

49. **Строки в JAVA. Интернированные строки. Что такое интернированные строки? Как JVM оптимизирует работу с повторяющимися строками? Примеры их использования.**

      **-** **Интернированные строки** — строки, сохранённые в пуле строк JVM. Если строка уже есть в пуле, новая ссылка указывает на неё. Это экономит память.

      **Пример:**

      ```java
      String s1 = "Hello";

      String s2 = new String("Hello").intern();

      System.out.println(s1 == s2); // true
      ```

      **-** JVM оптимизирует строки, уменьшая дублирование.

50. **Наследование в JAVA. Основные принципы наследования в Java. Что такое суперклассы(родительские) и подклассы(дочерние)? Как наследование помогает переиспользовать код? Примеры реализации наследования.**

      **-** **Наследование:** позволяет создавать новые классы на основе существующих (отношение "is-a").

      **-** **Суперкласс (родитель):** базовый класс.

      **-** **Подкласс (дочерний):** наследует свойства и методы суперкласса.

      **Пример:**

      ```java
      class Animal {
         void sound() {
            System.out.println("Animal sound");
         }
      }

      class Dog extends Animal {
         void sound() {
            System.out.println("Bark");
         }
      }
      ```

      **-** Наследование упрощает повторное использование кода и расширяет функциональность.

51. **Перегрузка метода в Java (overload). Переопределение метода в Java (override). В чем разница между перегрузкой и переопределением методов.**

      **-** **Перегрузка:** один класс, методы с одинаковым именем, но разными параметрами.

      ```java
      class Calculator {
         int add(int a, int b) {
            return a + b;
         }

         double add(double a, double b) {
            return a + b;
         }
      }
      ```

      **-** **Переопределение:** подкласс изменяет метод суперкласса с той же сигнатурой.

      ```java
      class Animal {
         void sound() {
            System.out.println("Generic sound");
         }
      }

      class Dog extends Animal {
         @Override
         void sound() {
            System.out.println("Bark");
         }
      }
      ```

      **-** Разница: перегрузка — одно имя, разная функциональность; переопределение — изменение поведения наследуемого метода.

52. **Наследование и отношение is-a. Как наследование реализует отношение «is-a»? Когда использование наследования может быть нецелесообразным? Примеры решений.**

      **-** **Наследование:** выражает отношение "is-a" между классами. Например, Dog **is-a** Animal.

      **Пример:**

      ```java
      class Animal { }

      class Dog extends Animal { } // Dog is-a Animal
      ```

      **-** **Когда наследование нецелесообразно:**

      1. Если подкласс не полностью соответствует суперклассу.
      2. Когда предпочтительнее использовать композицию ("has-a").<br>
         **Решение:** вместо наследования добавить объект в класс.

53. **Ключевое слово super. Роль ключевого слова super в Java. Использование для вызова методов и конструкторов суперкласса. Примеры реализации.**

      **-** super используется для:

      1. **Доступа к методу суперкласса:**

      ```java
      class Animal {
         void sound() {
            System.out.println("Generic sound");
         }
      }

      class Dog extends Animal {
         void sound() {
            super.sound();
            System.out.println("Bark");
         }
      }
      ```

      2. **Вызова конструктора суперкласса:**

      ```java
      class Animal {
         Animal(String name) {
            System.out.println(name);
         }
      }

      class Dog extends Animal {
         Dog() {
            super("Dog");
         }
      }
      ```

54. **Цепочка конструкторов. Понятие цепочки конструкторов. Как вызвать один конструктор из другого с использованием this() и super()? Примеры реализации.**

      **-** **Цепочка конструкторов:** вызов одного конструктора класса из другого для инициализации.

      **-** **this(): вызов конструктора текущего класса:**

      ```java
      class Person {
         Person() {
            this("Unknown");
         }

         Person(String name) {
            System.out.println("Name: " + name);
         }
      }
      ```

      **-** **super(): вызов конструктора суперкласса:**

      ```java
      class Animal {
         Animal(String type) {
            System.out.println("Type: " + type);
         }
      }

      class Dog extends Animal {
         Dog() {
            super("Dog");
         }
      }
      ```

      **-** Цепочка улучшает управление инициализацией объектов.

55. **Класс Object и его основные методы. Роль класса Object как суперкласса для всех классов в Java. Как метод toString() используется для представления объекта в виде строки? Примеры переопределения метода.**

      **-** **Класс Object:** базовый суперкласс для всех классов Java. Методы:

      * equals() — сравнивает объекты на равенство.
      * hashCode() — возвращает хеш-код объекта.
      * toString() — возвращает строковое представление объекта.
      * clone() — создает копию объекта.
      * finalize() — вызывается перед уничтожением объекта сборщиком мусора.
      * getClass() — возвращает класс объекта.
      * notify(), notifyAll(), wait() — методы для управления потоками.


      **-** **Пример переопределения toString:**

      ```java
      class Person {
         String name;

         Person(String name) {
            this.name = name;
         }

         @Override
         public String toString() {
            return "Person: " + name;
         }
      }
      ```

      **-** Используется для удобного вывода информации об объекте.

56. **Полиморфизм. Понятие полиморфизма в Java. Как переменная супертипа может ссылаться на объект подтипа? Примеры применения полиморфизма для создания гибкого кода.**

      **-** **Полиморфизм:** способность объекта подтипа быть обработанным как объект супертипа.

      **Пример:**

      ```java
      class Animal {
         void sound() {
            System.out.println("Some sound");
         }
      }

      class Dog extends Animal {
         void sound() {
            System.out.println("Bark");
         }
      }

      Animal a = new Dog(); // Переменная супертипа

      a.sound(); // Bark
      ```

      **-** Полиморфизм позволяет создавать гибкие и расширяемые программы, например, реализуя общие интерфейсы.

57. **Интерфейсы в Java. Понятие интерфейсов как конструкций для определения общих операций. Основные элементы интерфейсов: константы и абстрактные методы. Примеры использования интерфейсов для создания обобщенных решений.**

      **-** **Интерфейс:** определяет контракт (набор операций), который должны реализовать классы.

      * Содержит константы и абстрактные методы.
      * Объекты интерфейсов не создаются напрямую.

      **Пример:**

      ```java
      interface Movable {
         void move();
      }

      class Car implements Movable {
         public void move() {
            System.out.println("Car is moving");
         }
      }
      ```

      **-** Используется для создания обобщённых решений.

58. **Интерфейсы в Java. Понятие интерфейсов как конструкций для определения общих операций. Особенности интерфейсов, добавленные в JAVA 8 версии. Дефолтные методы в интерфейсах.**

      **-** **Особенности Java 8:**

      1. **Дефолтные методы:** методы с реализацией, чтобы избежать изменения всех классов при добавлении нового метода.

      ```java
      interface Movable {
         default void stop() {
            System.out.println("Stopped");
         }
      }
      ```

      2. **Статические методы:** методы интерфейса, вызываемые без создания объекта.

      ```java
      interface Utils {
         static void print(String msg) {
            System.out.println(msg);
         }
      }
      ```

      **-** Эти возможности повышают удобство работы с интерфейсами.

59. **Интерфейсы в Java. Особенности интерфейсов. Чем интерфейсы отличаются от классов? Как используются ключевые слова interface и implements? Примеры объявления и реализации интерфейсов.**

      **-** **Особенности интерфейсов:**

      * Интерфейсы содержат только методы без реализации (до Java 8).
      * Не могут хранить состояние (нет полей, кроме констант).
      * Реализуются с помощью ключевого слова implements.

      **Пример:**

      ```java
      interface Flyable {
         void fly();
      }

      class Bird implements Flyable {
         public void fly() {
            System.out.println("Flying");
         }
      }
      ```

      **-** **Отличие от классов:** классы могут содержать реализацию, состояние, а интерфейсы — только контракт.

60. **Интерфейсы в Java 8 и 9. Новые возможности интерфейсов, такие как default и static методы (Java 8), а также private и private static методы (Java 9). Примеры реализации и применения.**

      **-** **Java 8:**

      * **Default методы:** реализуемые в интерфейсе.

      ```java
      interface Movable {
         default void stop() {
            System.out.println("Stopped");
         }
      }
      ```

      * **Static методы:** вызываются через имя интерфейса.

      ```java
      interface Utils {
         static void print(String msg) {
            System.out.println(msg);
         }
      }
      ```

      **Java 9:**

      - **Private методы:** для внутренних операций.

      ```java
      interface Logger {
         private void log(String msg) { 
            System.out.println(msg);
         }
      }
      ```

      Эти возможности повышают гибкость и читаемость кода.

61. **Интерфейс Comparable. Как интерфейс Comparable используется для сравнения объектов? Реализация метода compareTo() и его роль в сортировке. Примеры работы с интерфейсом.**

      **-** **Comparable:** используется для определения естественного порядка объектов.

      **-** **Метод compareTo():** возвращает:

      * 0 — объекты равны.
      * < 0 — текущий объект меньше.
      * \> 0 — текущий объект больше.

      **Пример:**

      ```java
      class Person implements Comparable<Person> {
         int age;

         Person(int age) {
            this.age = age;
         }

         public int compareTo(Person other) {
            return this.age - other.age;
         }
      }
      ```

      **-** Используется для сортировки, например, в Collections.sort().

62. **Интерфейс Comparable для классов стандартной библиотеки JAVA. Как реализован интерфейс Comparable в классах String, Integer и Date? Примеры сравнения объектов с помощью метода compareTo().**

      **-** **String, Integer, Date:** реализуют Comparable для естественной сортировки.

      **Пример:**

      ```java
      String a = "Apple", b = "Banana";

      System.out.println(a.compareTo(b)); // -1 (Apple < Banana)

      Integer x = 5, y = 10;

      System.out.println(x.compareTo(y)); // -1 (5 < 10)
      ```

      **-** **Date:**

      ```java
      Date d1 = new Date(1000), d2 = new Date(2000);

      System.out.println(d1.compareTo(d2)); // -1
      ```

63. **Интерфейс Comparable для пользовательских классов. Как реализовать интерфейс Comparable для пользовательских классов? Примеры сравнения объектов на основе пользовательских критериев.**

      **-** **Реализация для сравнения по пользовательскому критерию:**

      **Пример:**

      ```java
      class Employee implements Comparable<Employee> {
         String name;
         int salary;

         Employee(String name, int salary) {
            this.name = name;
            this.salary = salary;
         }

         public int compareTo(Employee other) {
            return this.salary - other.salary;
         }
      }
      ```

      **-** Сортировка:

      ```java
      List<Employee> employees = Arrays.asList(
         new Employee("Alice", 5000),
         new Employee("Bob", 7000)
      );

      Collections.sort(employees); // Сортировка по зарплате
      ```

      **-** Пользовательский compareTo() упрощает сортировку объектов.

64. **Интерфейс Cloneable. Понятие клонирования объектов. Как интерфейс Cloneable позволяет клонировать объекты? Ограничения и примеры использования.**

      **-** Клонирование объектов в Java — это процесс создания точной копии объекта. Оно позволяет создать новый объект, который имеет те же значения полей, что и исходный объект.

      **-** **Cloneable:** интерфейс без методов, служащий маркером для клонирования объектов. Если класс реализует Cloneable, метод clone() может создавать копию объекта.

      **-** **Ограничения:**

      * Без реализации Cloneable метод clone() вызывает CloneNotSupportedException.
      * Клонирование неглубокое (shallow copy), если не переопределить clone().

      **Пример:**

      ```java
      class Person implements Cloneable {
         String name;

         Person(String name) {
            this.name = name;
         }

         @Override
         protected Object clone() throws CloneNotSupportedException {
            return super.clone();
         }
      }
      ```

65. **Метод clone(). Как метод clone(), определенный в классе Object, используется совместно с интерфейсом Cloneable? Примеры работы с клонируемыми объектами.**

      **-** Метод clone() из класса Object используется для создания копий объектов. Совместно с интерфейсом Cloneable он позволяет клонировать объекты.

      **Пример:**

      ```java
      class Person implements Cloneable {
         String name;

         Person(String name) {
            this.name = name;
         }

         @Override
         protected Object clone() throws CloneNotSupportedException {
            return super.clone();
         }
      }

      Person p1 = new Person("Alice");

      Person p2 = (Person) p1.clone();
      ```

      **-** p2 — копия p1. Для глубокого клонирования требуется дополнительная реализация.

66. **Интерфейсы и абстрактные классы. Основные различия между интерфейсами и абстрактными классами.** 

      **-** **Основные различия:**

      * **Интерфейсы:** определяют контракт (методы без реализации).
      * **Абстрактные классы:** содержат как абстрактные, так и конкретные методы.
      * Класс может наследовать только один абстрактный класс, но реализовывать множество интерфейсов.

      **-** **Когда использовать:**

      * Интерфейсы: для общих контрактов.
      * Абстрактные классы: для общего поведения.

67. **Понятие абстрактных классов в Java. Что такое абстрактный класс, и как он используется для создания общего базового поведения? Чем отличается абстрактный класс от интерфейса? Примеры объявления и реализации абстрактного класса с абстрактными и конкретными методами.**

      **-** **Абстрактный класс:** класс, который нельзя инстанцировать. Содержит абстрактные (без реализации) и конкретные методы.

      **Пример:**

      ```java
      abstract class Animal {
         abstract void sound();
         void eat() {
            System.out.println("Eating");
         }
      }

      class Dog extends Animal {
         @Override
         void sound() {
            System.out.println("Bark");
         }
      }
      ```

      **-** **Отличия от интерфейсов:**

      * Абстрактный класс может содержать состояние (поля).
      * Интерфейсы с Java 8+ поддерживают методы с реализацией (default).

68. **Понятие абстрактных классов в Java. Объявление абстрактных методов. Что такое абстрактный метод, и какие правила нужно соблюдать при его объявлении? Как абстрактные методы помогают подклассам реализовать специфическое поведение? Примеры реализации абстрактных методов в наследуемых классах.**

      **-** **Абстрактный метод:** метод без тела, определённый с ключевым словом abstract. Объявляется только в абстрактных классах.

      **-** **Правила:**

      * Подклассы обязаны реализовать абстрактные методы.
      * Абстрактные методы не могут быть final, static или private.

      **Пример:**

      ```java
      abstract class Animal {
         abstract void makeSound();
      }

      class Dog extends Animal {
         @Override
         void makeSound() {
            System.out.println("Bark");
         }
      }
      ```

      **-** Абстрактные методы обеспечивают реализацию специфического поведения в подклассах.

69. **Понятие абстрактных классов в Java. Особенности работы с абстрактными классами. Почему абстрактные классы нельзя инстанцировать? Как использовать абстрактный класс как основу для других классов? Примеры создания иерархии классов с базовым абстрактным классом.**

      **-** **Особенности:**

      * Нельзя создать экземпляр абстрактного класса напрямую.
      * Используются как шаблоны для реализации общих характеристик и поведения.
      * Могут содержать поля, конструкторы и конкретные методы.

      **Пример:**

      ```java
      abstract class Shape {
         abstract void draw();

         void description() {
            System.out.println("This is a shape");
         }
      }

      class Circle extends Shape {
         @Override
         void draw() {
            System.out.println("Drawing a circle");
         }
      }
      ```

      **-** Абстрактные классы создают основу для иерархии классов.

70. **Ограничение множественного наследования в JAVA. Множественное наследование интерфейсов. Как классы наследуют методы от нескольких интерфейсов.**

      **-** В Java отсутствует множественное наследование классов для предотвращения конфликта реализаций. Вместо этого поддерживается множественное наследование интерфейсов.

      **Пример:**

      ```java
      interface Flyable {
         void fly();
      }

      interface Swimmable {
         void swim();
      }

      class Bird implements Flyable, Swimmable {
         @Override
         public void fly() {
            System.out.println("Flying");
         }

         @Override
         public void swim() {
            System.out.println("Swimming");
         }
      }
      ```

      **-** Класс может реализовать методы нескольких интерфейсов, обеспечивая гибкость.

71. **Интерфейсы в Java. Особенности интерфейсов. Интерфейсы и полиморфизм. Как интерфейсы способствуют реализации полиморфизма?**

      **-** **Роль интерфейсов в полиморфизме:**

      * Интерфейсы позволяют создавать объекты, которые можно использовать через общие типы.
      * Полиморфизм обеспечивается, так как разные классы могут реализовывать один интерфейс с уникальным поведением.

      **Пример:**

      ```java
      interface Animal {
         void makeSound();
      }

      class Dog implements Animal {
         @Override
         public void makeSound() {
            System.out.println("Bark");
         }
      }

      class Cat implements Animal {
         @Override
         public void makeSound() {
            System.out.println("Meow");
         }
      }

      Animal a = new Dog();

      a.makeSound(); // Bark
      ```

      **-** Интерфейсы обеспечивают гибкость и расширяемость кода.

72. **Обработка исключительных ситуаций в JAVA. Основные способы и подходы к обработке исключительных ситуаций в JAVA. Иерархия классов исключений в Java. Понятие и структура иерархии исключений. Чем отличаются классы Error, Exception и RuntimeException?**

      **-** Основные способы и подходы к обработке исключительных ситуаций в JAVA:

      * Использование try-catch
      * Использование try-catch-finally
      * Использование throws с try-catch
      * Перехват нескольких исключений:
      ```java
      try {
         int result = 10 / 0;
         int[] numbers = {1, 2, 3};
         System.out.println(numbers[5]);
      } catch (ArithmeticException | ArrayIndexOutOfBoundsException e) {
         System.out.println("Error: " + e.getMessage());
         // Error: / by zero
      }
      ```

      **-** Иерархия исключений в Java представляет собой структуру классов, унаследованных от базового класса Throwable, который является корневым для всех ошибок и исключений.

      **-** Иерархия классов исключений в Java:

      * **Throwable** — базовый класс.
      * **Error** — ошибки уровня JVM (например, OutOfMemoryError). Не подлежат обработке.
      * **Exception** — ошибки, которые можно обработать.
         * **RuntimeException** — необрабатываемые исключения (например, NullPointerException).

      **-** **Отличия:**

      * Error: серьезные ошибки, не обрабатываются.
      * Exception: обрабатываемые ошибки.
      * RuntimeException: не требуют обязательного try-catch.

73. **Создание и генерация исключений. Как создавать и генерировать исключения с помощью ключевого слова throw? Различия между throw и throws. Примеры создания пользовательских исключений.**

      **-** **throw:** используется для генерации исключения.

      **-** **throws:** объявляет исключения, которые метод может выбросить.

      **Пример:**

      ```java
      void validateAge(int age) throws IllegalArgumentException {
         
         if (age < 18) throw new IllegalArgumentException("Age must be 18+");

      }
      ```

      **-** **Пользовательское исключение:**

      ```java
      class MyException extends Exception {
         public MyException(String message) {
            super(message);
         }
      }
      ```

      **-** **Различия:**

      * throw: генерирует исключение.
      * throws: информирует вызывающий код об исключении.

74. **Обработка исключений. Структура блока try-catch. Как обрабатывать исключения с использованием блоков try-catch? Примеры обработки нескольких исключений и упорядочения блоков catch. Роль объекта исключения (Exception e) в блоке catch.**

      **-** **Структура:**

      ```java
      try {

         // Код, который может выбросить исключение

      } catch (ExceptionType1 e1) {

         // Обработка исключения 1

      } catch (ExceptionType2 e2) {

         // Обработка исключения 2

      }
      ```

      **Пример:**

      ```java
      try {
         int result = 10 / 0;
      } catch (ArithmeticException e) {
         System.out.println("Division by zero error: " + e.getMessage());
      }
      ```

      **-** Блоки catch обрабатывают исключения в порядке их убывающей специфичности.

      **-** В блоке catch объект исключения (например, Exception e) играет ключевую роль в обработке ошибки, предоставляя разработчику доступ к информации об исключении и позволяя выполнить действия для устранения или регистрации проблемы.

75. **Обработка исключений. Структура блока try-catch. Блок finally и его использование. Основные причины использования. Примеры использования.**

      **-** **finally:** выполняется независимо от того, было исключение или нет. Используется для освобождения ресурсов (закрытие файлов, соединений и т.д.).

      **Пример:**

      ```java
      try {
         int[] arr = {1, 2};
         System.out.println(arr[5]);
      } catch (ArrayIndexOutOfBoundsException e) {
         System.out.println("Invalid index");
      } finally {
         System.out.println("Execution complete");
      }
      ```

      **-** **Роль:**

      * Гарантирует выполнение завершающего кода.
      * Полезен для управления ресурсами.

76. **Обработка исключений. Пропагирование исключений. Как исключения передаются вверх по стеку вызовов? Примеры использования ключевого слова throws в сигнатуре методов.**

      **-** Исключения передаются вверх по стеку вызовов, если они не обрабатываются в текущем методе. Метод, вызывающий метод с исключением, должен либо обработать его, либо объявить в throws.

      **Пример:**

      ```java
      void method1() throws Exception {
         throw new Exception("Error in method1");
      }

      void method2() throws Exception {
         method1();
      }
      ```

      **-** **Использование:**

      * throws в сигнатуре указывает вызывающему коду на необходимость обработки исключения.

77. **Обработка исключений. Проверяемые и непроверяемые исключения. Какие исключения считаются проверяемыми (checked), а какие - непроверяемыми (unchecked)? Примеры работы с ними. Исключения в популярных фреймворках. Почему большинство исключений в современных фреймворках являются непроверяемыми?**

      * **Проверяемые (Checked):** подклассы Exception, кроме RuntimeException. Требуют обработки (например, IOException, SQLException).
      * **Непроверяемые (Unchecked):** подклассы RuntimeException или Error. Обработка необязательна (например, NullPointerException).

      **Пример:**

      ```java
      // Checked
      try {
         throw new IOException("Checked Exception");
      } catch (IOException e) {
         e.printStackTrace();
      }

      // Unchecked
      int result = 10 / 0; // ArithmeticException
      ```

      **-** **Фреймворки:**<br>
      Современные фреймворки используют unchecked исключения для упрощения кода, т.к. они не требуют обязательного try-catch.

78. **Обработка исключений. Использование try-with-resources. Как она упрощает управление ресурсами? Примеры работы.**

      **-** try-with-resources автоматически закрывает ресурсы, реализующие интерфейс AutoCloseable.

      **Пример:**

      ```java
      try (BufferedReader reader = new BufferedReader(new FileReader("file.txt"))) {
         System.out.println(reader.readLine());
      } catch (IOException e) {
         e.printStackTrace();
      }
      ```

      **-** **Преимущества:**

      * Автоматическое освобождение ресурсов.
      * Уменьшение объема кода.

79. **Обработка исключитеьных ситуаций в JAVA. Роль JVM в обработке исключений. Как JVM управляет исключениями, если они не были обработаны? Примеры поведения при неперехваченных исключениях.**

      **-** Если исключение не обработано, JVM завершает выполнение программы, вызывая метод printStackTrace() и отображая стек вызовов.

      **-** **Пример поведения:**

      ```java
      void method() {
         throw new RuntimeException("Unhandled Exception");
      }
      ```

      **-** Вывод:

      ```php
      Exception in thread "main" java.lang.RuntimeException: Unhandled Exception
         at Example.method(Example.java:3)
         at Example.main(Example.java:7)
      ```

      **-** Роль JVM:

      * Управляет поиском подходящего обработчика.
      * Завершает поток при отсутствии обработки.

80. **Перечисления (enums) в Java. Что такое перечисления и как они используются для создания фиксированных наборов значений? Характеристики перечислений. Перечисления и типобезопасность. Примеры их применения.**

      **-** **Перечисления:** специальный тип для фиксированных наборов значений. Они являются типобезопасными и статически проверяемыми.

      **Пример:**

      ```java
      enum Day { MONDAY, TUESDAY, WEDNESDAY }

      Day today = Day.MONDAY;

      System.out.println(today); // MONDAY
      ```

      **-** **Характеристики:**

      - Поддерживают методы и поля.
      - Типобезопасность: исключают ошибки ввода.
      - Используются для представления фиксированных наборов данных (например, дни недели).

81. **GUI в Java. Что такое GUI (графический пользовательский интерфейс)? Основные пакеты для работы с GUI в Java: AWT и Swing.**

      **-** **GUI (Graphical User Interface):** интерфейс, позволяющий взаимодействовать с приложением через визуальные элементы (кнопки, окна, текстовые поля).

      **-** Основные пакеты:

      * **AWT (Abstract Window Toolkit):** базовый API для создания GUI, зависящий от платформы.
      * **Swing:** расширение AWT, предоставляет больше возможностей и платформонезависимые компоненты.

      **-** Пример компонентов: окна (Frame), кнопки (Button), текстовые поля (TextField).

82. **GUI в Java. Структура GUI в JAVA при реализации через Swing и AWT. Компоненты GUI. Какие элементы составляют графический интерфейс? Примеры кнопок, текстовых полей и других компонентов.**

      **-** **Компоненты GUI:**

      * Контейнеры: Frame, Panel, JPanel.
      * Визуальные элементы: кнопки (Button, JButton), текстовые поля (TextField, JTextField), метки (Label, JLabel).

      **Пример:**

      ```java
      JFrame frame = new JFrame("Example");
      
      JButton button = new JButton("Click Me");
      JTextField textField = new JTextField();
      JLabel label = new JLabel("Enter text and click the button");      

      frame.add(button);
      frame.add(textField);
      frame.add(label);

      frame.setSize(300, 200);

      frame.setVisible(true);
      ```

      **-** Элементы GUI размещаются в контейнерах, упрощая структурирование.

1. **AWT (Abstract Window Toolkit). Что такое AWT и как он используется для создания GUI? Примеры простых интерфейсов с использованием AWT.**

      **-** **AWT:** библиотека для создания GUI, использующая нативные ресурсы системы. Поддерживает базовые компоненты, но менее гибкий, чем Swing.

      **-** **Пример AWT интерфейса:**

      ```java
      import java.awt.*;

      public class AWTExample {
         public static void main(String[] args) {
            Frame frame = new Frame("AWT Example");
            Button button = new Button("Click Me");

            frame.add(button);

            frame.setSize(300, 200);
            frame.setVisible(true);
         }
      }
      ```

      **-** **Недостатки:** зависит от платформы, ограниченные компоненты.

84. **Swing в Java. Как Swing расширяет возможности AWT? Примеры создания интерфейсов с использованием Swing. Паттерн MVC в Swing. Как Swing реализует модель MVC (Model-View-Controller)? Примеры разделения логики, представления и управления в интерфейсе.**

      **-** **Swing:** расширение AWT, предоставляет больше настраиваемых и легковесных компонентов. Swing работает независимо от платформы.

      **-** **Пример Swing интерфейса:**

      ```java
      import javax.swing.*;

      public class SwingExample {
         public static void main(String[] args) {
            JFrame frame = new JFrame("Swing Example");
            JButton button = new JButton("Click Me");

            frame.add(button);
            frame.setSize(300, 200);

            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            frame.setVisible(true);
         }
      }
      ```

      **-** **MVC в Swing:**

      - **Model:** данные (например, текст в текстовом поле).
      - **View:** отображение данных (компонент).
      - **Controller:** обработка событий (нажатие кнопки).

      **-** Swing разделяет эти части, упрощая разработку и тестирование.<br>
      **Пример:** JTable (данные – TableModel, отображение – таблица, управление – события).

85. **Структура GUI в Java. Основные компоненты GUI в Swing: контейнеры (JFrame, JPanel, JDialog), компоненты (JButton, JLabel, JTextField) и менеджеры компоновки.** 

      **-** **Основные компоненты Swing:**

      1. **Контейнеры:**
         1. **JFrame:** главное окно приложения.
         2. **JPanel:** панель для группировки компонентов.
         3. **JDialog:** модальное окно для отображения сообщений или дополнительных форм.
      2. **Компоненты:**
         1. **JButton:** кнопка.
         2. **JLabel:** текстовая метка.
         3. **JTextField:** текстовое поле.
      3. **Менеджеры компоновки:**
         1. Автоматически размещают компоненты: FlowLayout, BorderLayout, GridLayout.

      **Пример:**

      ```java
      JFrame frame = new JFrame("Example");

      frame.setLayout(new FlowLayout());

      frame.add(new JButton("Click Me"));
      frame.add(new JTextField(10));

      frame.setSize(300, 200);
      frame.setVisible(true);
      ```

1. **Класс JFrame. Что такое окно JFrame, и как использовать его для создания графического интерфейса? Примеры добавления элементов через метод getContentPane().**

      **-** **JFrame:** главное окно для GUI-приложений. Оно предоставляет область для добавления компонентов через **getContentPane()**.

      **-** **Пример использования JFrame:**

      ```java
      import javax.swing.*;
      import java.awt.*;

      public class JFrameExample {
         public static void main(String[] args) {
            JFrame frame = new JFrame("JFrame Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setLayout(new FlowLayout());

            frame.getContentPane().add(new JButton("Click Me"));

            frame.setSize(300, 200);
            frame.setVisible(true);
         }
      }
      ```

      **-** **Методы:**

      * setSize(int, int) – устанавливает размер окна.
      * setLayout(LayoutManager) – задает компоновку компонентов.
      * setVisible(true) – отображает окно.

87. **Класс JPanel. Как панель JPanel используется для группировки и управления компонентами? Примеры изменения менеджера компоновки с помощью метода setLayout().**

      **-** **JPanel:** вспомогательная панель для группировки компонентов и управления их размещением. Может использовать различные **менеджеры компоновки** через метод **setLayout()**.

      **-** **Пример использования JPanel:**

      ```java
      import javax.swing.*;
      import java.awt.*;

      public class JPanelExample {
         public static void main(String[] args) {
            JFrame frame = new JFrame("JPanel Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            JPanel panel = new JPanel();
            panel.setLayout(new GridLayout(2, 2));

            panel.add(new JLabel("Label 1"));
            panel.add(new JTextField("TextField 1"));

            panel.add(new JLabel("Label 2"));
            panel.add(new JTextField("TextField 2"));

            frame.add(panel);

            frame.setSize(300, 200);
            frame.setVisible(true);
         }
      }

88. **Менеджеры компоновки в Java. Роль менеджеров компоновки в управлении размещением компонентов. Примеры использования менеджеров FlowLayout, BorderLayout, GridLayout.**

      **-** **Роль:** менеджеры компоновки управляют размещением и размерами компонентов в контейнерах.

      1. **FlowLayout:** размещает компоненты по порядку, как текст в строке.

      ```java
      panel.setLayout(new FlowLayout());
      ```

      2. **BorderLayout:** разделяет контейнер на пять областей: North, South, East, West, Center.

      ```java
      frame.setLayout(new BorderLayout());

      frame.add(new JButton("North"), BorderLayout.NORTH);
      ```

      3. **GridLayout:** создает таблицу из строк и столбцов.

      ```java
      panel.setLayout(new GridLayout(2, 2)); // 2 строки, 2 столбца
      ```

      **-** **Пример работы с менеджерами:**

      ```java
      import javax.swing.*;
      import java.awt.*;

      public class LayoutExample {
         public static void main(String[] args) {
            JFrame frame = new JFrame("Layout Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            JPanel panel = new JPanel();
            panel.setLayout(new FlowLayout());

            panel.add(new JButton("Button 1"));
            panel.add(new JButton("Button 2"));
            panel.add(new JButton("Button 3"));

            frame.add(panel);

            frame.setSize(300, 200);
            frame.setVisible(true);
         }
      }
      ```

89. **Менеджер FlowLayout. Как работает FlowLayout? Примеры настройки выравнивания и промежутков между компонентами.**

      **-** **FlowLayout:**

      * Размещает компоненты слева направо в одну или несколько строк.
      * Если компоненты не помещаются в одну строку, они переносятся на следующую.

      **-** **Параметры настройки:**

      * Выравнивание: FlowLayout.LEFT, FlowLayout.CENTER (по умолчанию), FlowLayout.RIGHT.
      * Промежутки: можно задать горизонтальный и вертикальный отступы между компонентами.

      **-** **Пример работы с FlowLayout:**

      ```java
      import javax.swing.*;
      import java.awt.*;

      public class FlowLayoutExample {
         public static void main(String[] args) {
            JFrame frame = new JFrame("FlowLayout Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            JPanel panel = new JPanel();

            panel.setLayout(new FlowLayout(FlowLayout.CENTER, 20, 10)); // Центрирование, 20px горизонтальный и 10px вертикальный отступы

            panel.add(new JButton("Button 1"));
            panel.add(new JButton("Button 2"));
            panel.add(new JButton("Button 3"));

            frame.add(panel);

            frame.setSize(300, 150);
            frame.setVisible(true);
         }
      }
      ```

90. **Менеджеры компоновки в Java. Роль менеджеров компоновки в управлении размещением компонентов. Примеры использования менеджеров FlowLayout, BorderLayout, GridLayout.**

      **-** **Роль менеджеров компоновки:**

      * Управляют размещением компонентов в контейнере, упрощая создание адаптивного интерфейса.
      * Позволяют избежать абсолютных координат, делая интерфейс более гибким.

      **-** **Примеры менеджеров:**

      1. **FlowLayout:**
         1. Рядовой порядок, компоненты переносятся на следующую строку.
         2. Пример: см. выше (вопрос 89).
      2. **BorderLayout:**
         1. Делит контейнер на 5 областей: NORTH, SOUTH, EAST, WEST, CENTER.

      ```java
      frame.setLayout(new BorderLayout());

      frame.add(new JButton("North"), BorderLayout.NORTH);
      frame.add(new JButton("Center"), BorderLayout.CENTER);
      ```

      3. **GridLayout:**
         1. Таблица из строк и столбцов, все ячейки одинакового размера.

      ```java
      panel.setLayout(new GridLayout(2, 2)); // 2 строки, 2 столбца

      panel.add(new JButton("1"));
      panel.add(new JButton("2"));
      ```

91. **Менеджер FlowLayout. Как работает FlowLayout? Примеры настройки выравнивания и промежутков между компонентами.**

      **-** Go to Question 89

92. **Менеджер BorderLayout. Как BorderLayout делит контейнер на регионы (NORTH, SOUTH, EAST, WEST, CENTER)? Примеры создания интерфейсов с четкой организацией областей.**

      **-** **BorderLayout:**

      * Делит контейнер на 5 областей:
         * NORTH: верхняя область.
         * SOUTH: нижняя область.
         * EAST: правая область.
         * WEST: левая область.
         * CENTER: центральная область.
      * Любая из областей может быть пустой.
      * Центральная область растягивается, если другие области не занимают всё пространство.

      **-** **Пример использования BorderLayout:**

      ```java
      import javax.swing.*;
      import java.awt.*;

      public class BorderLayoutExample {
         public static void main(String[] args) {
            JFrame frame = new JFrame("BorderLayout Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            frame.setLayout(new BorderLayout());

            frame.add(new JButton("North"), BorderLayout.NORTH);
            frame.add(new JButton("South"), BorderLayout.SOUTH);
            frame.add(new JButton("East"), BorderLayout.EAST);
            frame.add(new JButton("West"), BorderLayout.WEST);
            frame.add(new JButton("Center"), BorderLayout.CENTER);

            frame.setSize(400, 300);
            frame.setVisible(true);
         }
      }
      ```

      **-** **Роль BorderLayout:** четкая организация интерфейса для окон, где важно распределение элементов по областям.

93. **Менеджер GridLayout. Как компоненты размещаются в сетке с использованием GridLayout? Примеры создания таблиц или форм.**

      **-** **GridLayout:**

      * Делит контейнер на равные ячейки, образуя сетку (таблицу).
      * Компоненты заполняют ячейки слева направо и сверху вниз.

      **-** **Конструкторы:**

      1. GridLayout(rows, cols) — задаёт количество строк и столбцов.
      1. GridLayout(rows, cols, hgap, vgap) — дополнительно задаёт горизонтальные и вертикальные промежутки.

      **-** **Пример: создание формы с GridLayout:**

      ```java
      import javax.swing.*;
      import java.awt.*;

      public class GridLayoutExample {
         public static void main(String[] args) {
            JFrame frame = new JFrame("GridLayout Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            frame.setLayout(new GridLayout(3, 2, 10, 10)); // 3 строки, 2 столбца, промежутки 10px

            frame.add(new JLabel("Name:"));
            frame.add(new JTextField());

            frame.add(new JLabel("Email:"));
            frame.add(new JTextField());

            frame.add(new JButton("Submit"));
            frame.add(new JButton("Cancel"));

            frame.setSize(300, 150);
            frame.setVisible(true);
         }
      }
      ```

94. **Менеджер BoxLayout. Как компоненты размещаются по горизонтали или вертикали с помощью BoxLayout? Примеры последовательного расположения элементов.**

      **-** **BoxLayout:**

      * Размещает компоненты **по горизонтали** (BoxLayout.X\_AXIS) или **по вертикали** (BoxLayout.Y\_AXIS).
      * Более гибкий в сравнении с FlowLayout, позволяет задавать отступы и выравнивание.

      **-** **Пример: вертикальное расположение компонентов:**

      ```java
      import javax.swing.*;
      import java.awt.*;

      public class BoxLayoutExample {
         public static void main(String[] args) {
            JFrame frame = new JFrame("BoxLayout Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            JPanel panel = new JPanel();
            panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));

            panel.add(new JButton("Button 1"));
            panel.add(Box.createRigidArea(new Dimension(0, 10))); // Вертикальный промежуток
            panel.add(new JButton("Button 2"));
            panel.add(Box.createVerticalGlue()); // Растягивающийся промежуток
            panel.add(new JButton("Button 3"));

            frame.add(panel);

            frame.setSize(200, 200);
            frame.setVisible(true);
         }
      }
      ```

95. **Границы в Swing. Как использовать границы для улучшения внешнего вида интерфейса? Примеры применения границ.**

      **-** **Границы (Borders):**

      * Улучшают внешний вид компонентов, добавляя рамки, отступы или выделение.
      * Границы можно задать с помощью метода setBorder() для любого компонента.

      **-** **Основные типы границ (класс javax.swing.border.Border):**

      1. LineBorder: простая линия.
      2. EmptyBorder: пустые отступы.
      3. EtchedBorder: граница с эффектом вдавленности.
      4. TitledBorder: граница с заголовком.

      **-** **Пример: использование границ:**

      ```java
      import javax.swing.*;
      import javax.swing.border.*;

      public class BorderExample {
         public static void main(String[] args) {
            JFrame frame = new JFrame("Border Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            JPanel panel = new JPanel();
            panel.setBorder(BorderFactory.createTitledBorder("Panel Title")); // Граница с заголовком

            panel.add(new JButton("Button 1"));
            panel.add(new JButton("Button 2"));

            frame.add(panel);

            frame.setSize(300, 200);
            frame.setVisible(true);
         }
      }
      ```

96. **GUI и событийная модель в Java. Что такое событийная модель, и как она используется для взаимодействия компонентов через события? Основные элементы событийной модели.**

      **-** **Событийная модель (Event Model):**

      * Определяет механизм обработки событий (например, нажатие кнопок, ввод текста).
      * Включает три основных элемента:
         * **Источник события (Event Source):** генерирует события (например, кнопка, текстовое поле).
         * **Слушатель события (Event Listener):** объект, который ожидает события и выполняет действия.
         * **Событие (Event):** объект, содержащий информацию о произошедшем действии.

      **-** **Пример взаимодействия:**

      * Слушатель (ActionListener) обрабатывает событие от кнопки.

      **-** **Пример: реализация событийной модели:**

      ```java
      import javax.swing.*;

      import java.awt.event.ActionEvent;
      import java.awt.event.ActionListener;

      public class EventModelExample {
         public static void main(String[] args) {
            JFrame frame = new JFrame("Event Model Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            JButton button = new JButton("Click Me");
            JLabel label = new JLabel("Button not clicked");

            button.addActionListener(new ActionListener() { // Добавление слушателя события
               @Override
               public void actionPerformed(ActionEvent e) {
                  label.setText("Button clicked!");
               }
            });

            frame.setLayout(new BoxLayout(frame.getContentPane(), BoxLayout.Y_AXIS));

            frame.add(button);
            frame.add(label);

            frame.setSize(200, 150);
            frame.setVisible(true);
         }
      }
      ```

      **-** **Роль событийной модели:**

      * Организует взаимодействие между пользователем и интерфейсом.
      * Позволяет эффективно реагировать на действия пользователя.

97. **Обработка событий в Java. Как источник события, слушатель и обработчик взаимодействуют в событийной модели? Примеры добавления слушателей событий. Модель делегирования событий. Как работает модель делегирования событий?** 

      **-** **Событийная модель в Java**

      * **Источник события (Event Source):** генерирует события (например, кнопки, текстовые поля).
      * **Слушатель события (Event Listener):** ожидает события и определяет, что делать, если оно произошло.
      * **Обработчик события (Event Handler):** код, выполняющийся при обработке события.

      **-** **Модель делегирования событий**

      * Основана на **разделении обязанностей**:
      * Источник генерирует событие.
      * Слушатель "слушает" источник.
      * Обработчик выполняет действия.

      **-** **Добавление слушателей**

      * Слушатели добавляются через методы, например, addActionListener().

      **-** **Пример: работа с кнопкой и событием:**

      ```java
      import javax.swing.*;

      import java.awt.event.ActionEvent;
      import java.awt.event.ActionListener;

      public class EventDelegationExample {
         public static void main(String[] args) {
            JFrame frame = new JFrame("Event Delegation Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            JButton button = new JButton("Click Me");

            button.addActionListener(new ActionListener() { // Слушатель события
               @Override
               public void actionPerformed(ActionEvent e) {
                  System.out.println("Button clicked!");
               }
            });

            frame.add(button);

            frame.setSize(200, 150);
            frame.setVisible(true);
         }
      }
      ```

98. **Обработка событий при реализации GUI в JAVA. Классы событий пакета java.awt.event. Какие классы событий предоставляет пакет java.awt.event? Примеры обработки событий мыши и клавиатуры.**

      **-** **Основные классы событий в пакете java.awt.event:**

      * **ActionEvent**: действие (например, нажатие кнопки).
      * **MouseEvent**: действия мыши (нажатие, перемещение).
      * **KeyEvent**: нажатия клавиш.
      * **WindowEvent**: события окна (закрытие, минимизация).
      * **ItemEvent**: выбор элементов (например, в чекбоксах).

      **-** **Пример: обработка событий мыши и клавиатуры:**

      ```java
      import javax.swing.*;

      import java.awt.event.*;

      public class EventExample {
         public static void main(String[] args) {
            JFrame frame = new JFrame("Event Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            JTextField textField = new JTextField("Type something...");
            JLabel label = new JLabel("Mouse events will be shown here");

            textField.addKeyListener(new KeyAdapter() {
               @Override
               public void keyTyped(KeyEvent e) {
                  System.out.println("Key Typed: " + e.getKeyChar());
               }
            });

            label.addMouseListener(new MouseAdapter() {
               @Override
               public void mouseClicked(MouseEvent e) {
                  System.out.println("Mouse clicked at: " + e.getPoint());
               }
            });

            frame.add(textField, "North");
            frame.add(label, "Center");

            frame.setSize(300, 200);
            frame.setVisible(true);
         }
      }
      ```

99. **Обработка событий мыши в JAVA. Как использовать интерфейсы MouseListener и MouseMotionListener для обработки событий мыши? Примеры обработки нажатий и перемещений.**

      **-** **Интерфейсы:**

      1. **MouseListener**: отслеживает нажатия/отпускания кнопок мыши.
      2. **MouseMotionListener**: обрабатывает перемещения мыши.

      **-** **Методы интерфейсов:**

      * mouseClicked(MouseEvent e) — нажатие кнопки мыши.
      * mousePressed(MouseEvent e) — удержание кнопки мыши.
      * mouseReleased(MouseEvent e) — отпускание кнопки.
      * mouseEntered(MouseEvent e) — курсор входит в компонент.
      * mouseExited(MouseEvent e) — курсор выходит из компонента.
      * mouseDragged(MouseEvent e) — курсор перемещается с зажатой кнопкой.
      * mouseMoved(MouseEvent e) — курсор перемещается.

      **-** **Пример: работа с мышью:**

      ```java
      import javax.swing.*;

      import java.awt.event.*;

      public class MouseListenerExample {
         public static void main(String[] args) {
            JFrame frame = new JFrame("Mouse Listener Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            JLabel label = new JLabel("Click or move the mouse");

            label.addMouseListener(new MouseAdapter() {
               @Override
               public void mouseClicked(MouseEvent e) {
                  System.out.println("Mouse clicked at: " + e.getPoint());
               }

               @Override
               public void mouseEntered(MouseEvent e) {
                  System.out.println("Mouse entered the label");
               }
            });

            label.addMouseMotionListener(new MouseMotionAdapter() {
               @Override
               public void mouseMoved(MouseEvent e) {
                  System.out.println("Mouse moved to: " + e.getPoint());
               }
            });

            frame.add(label);

            frame.setSize(300, 200);
            frame.setVisible(true);
         }
      }
      ```

100. **Обработка событий клавиатуры в JAVA. Как обрабатывать события клавиатуры с использованием KeyListener? Примеры регистрации слушателей клавиатурных событий.**

      **-** **Интерфейс KeyListener:**

      * Используется для обработки клавиатурных событий.

      **-** **Методы интерфейса:**

      1. keyTyped(KeyEvent e) — символ был введён.
      2. keyPressed(KeyEvent e) — клавиша была нажата.
      3. keyReleased(KeyEvent e) — клавиша была отпущена.

      **-** **Пример: регистрация клавиш:**

      ```java
      import javax.swing.*;

      import java.awt.event.*;

      public class KeyListenerExample {
         public static void main(String[] args) {
            JFrame frame = new JFrame("Key Listener Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            JTextField textField = new JTextField("Type here...");

            textField.addKeyListener(new KeyAdapter() {
               @Override
               public void keyPressed(KeyEvent e) {
                  System.out.println("Key pressed: " + e.getKeyCode());
               }

               @Override
               public void keyReleased(KeyEvent e) {
                  System.out.println("Key released: " + e.getKeyCode());
               }
            });

            frame.add(textField);

            frame.setSize(300, 100);
            frame.setVisible(true);
         }
      }
      ```

      **-** **Результат:**

      * Обрабатывает ввод с клавиатуры.
      * Распечатывает код клавиши и символы.

101. **Обобщённое программирование в Java. Понятие обобщённого программирования и его роль в упрощении создания алгоритмов для работы с различными типами данных. История разваития в JAVA. Примеры проектирования универсальных структур данных и алгоритмов.**

      **-** Обобщённое программирование — это подход к проектированию программ, при котором создаются универсальные алгоритмы, структуры данных или классы, способные работать с различными типами данных без изменения кода.

      **-** **Роль в упрощении разработки**

      * **Типобезопасность:** устранение ошибок на этапе компиляции.
      * **Повторное использование кода:** один универсальный класс или метод для множества типов.
      * **Читаемость и ясность:** вместо использования базовых типов (Object) применяется конкретизация.

      **-** **История развития в Java**

      * До Java 1.5 разработчики использовали сырые типы (raw types) и преобразования вручную, что увеличивало риск ошибок.
      * С Java 5 были введены **Generics** для повышения безопасности и упрощения работы с коллекциями и структурами данных.

      **-** **Пример проектирования универсальных структур данных**

      * Обобщённый класс для стека:

      ```java
      public class GenericStack<T> {
         private ArrayList<T> stack = new ArrayList<>();

         public void push(T item) {
            stack.add(item);
         }

         public T pop() {
            if (!stack.isEmpty()) {
               return stack.remove(stack.size() - 1);
            }

            throw new EmptyStackException();
         }

         public boolean isEmpty() {
            return stack.isEmpty();
         }
      }
      ```

      * **Использование:**

      ```java
      GenericStack<Integer> intStack = new GenericStack<>();

      intStack.push(10);
      intStack.push(20);

      System.out.println(intStack.pop()); // 20

      GenericStack<String> stringStack = new GenericStack<>();

      stringStack.push("Hello");

      System.out.println(stringStack.pop()); // Hello
      ```

102. **Generics в Java. Реализация обобщенного программирования через Generics. Основные синтаксические конструкции: параметры типов, обобщенные классы и методы. Примеры работы с параметризованными классами и методами. Примущества и недостатки Generics.**

      **-** **Реализация обобщённого программирования через Generics**

      * Generics позволяют параметризовать типы данных. Основные элементы:
         1. **Параметры типов:** обозначаются заглавными буквами (T, E, K, V).
         2. **Обобщённые классы:** классы, работающие с любым типом данных.
         3. **Обобщённые методы:** методы, принимающие параметры любого типа.

      **-** **Пример обобщённого класса**

      ```java
      public class Pair<K, V> {
         private K key;
         private V value;

         public Pair(K key, V value) {
            this.key = key;
            this.value = value;
         }

         public K getKey() {
            return key;
         }

         public V getValue() {
            return value;
         }
      }
      ```

      **-** **Использование:**

      ```java
      Pair<String, Integer> pair = new Pair<>("Age", 25);

      System.out.println(pair.getKey() + ": " + pair.getValue());
      ```

      **-** **Преимущества Generics**

      * Типобезопасность.
      * Снижение необходимости в преобразованиях типов.
      * Универсальность кода.

      **-** **Недостатки**

      * Ограничения, связанные с типами (например, невозможность использовать примитивные типы).
      * Невозможность работы с массивами обобщённых типов напрямую.

103. **Коллекции и Generics в Java. Как использование Generics повысило типобезопасность коллекций, таких как ArrayList, HashMap и HashSet? Примеры создания и обработки коллекций с обобщениями.**

      **-** До Java 5 коллекции (например, ArrayList) работали с сырыми типами (raw types), что требовало явного преобразования типов. С введением Generics коллекции стали параметризованными.

      **-** **Примеры работы с Generics в коллекциях**

      * **Старый подход:**

      ```java
      ArrayList list = new ArrayList();

      list.add("Hello");

      String str = (String) list.get(0); // Преобразование типов
      ```

      * **С использованием Generics:**

      ```java
      ArrayList<String> list = new ArrayList<>();

      list.add("Hello");

      String str = list.get(0); // Типобезопасность
      ```

      * **Пример с HashMap:**

      ```java
      HashMap<String, Integer> map = new HashMap<>();

      map.put("One", 1);
      map.put("Two", 2);

      for (Map.Entry<String, Integer> entry : map.entrySet()) {
         System.out.println(entry.getKey() + " = " + entry.getValue());
      }
      ```

104. **Параметризованные методы. Понятие параметризованных методов в Java. Как они позволяют работать с любыми типами данных? Примеры реализации методов с обобщенными параметрами и их вызова.**

      **-** Обобщённые методы — это методы, которые принимают один или несколько параметров типа, независимо от обобщённости самого класса.

      **-** **Пример реализации**

      ```java
      public class GenericMethods {
         public static <T> void printArray(T[] array) {
            for (T item : array) {
               System.out.print(item + " ");
            }

            System.out.println();
         }
      }
      ```

      **-** **Использование:**

      ```java
      public class Main {
         public static void main(String[] args) {
            Integer[] intArray = {1, 2, 3, 4};
            String[] strArray = {"A", "B", "C"};

            GenericMethods.printArray(intArray); // 1 2 3 4
            GenericMethods.printArray(strArray); // A B C
         }
      }
      ```

      **-** **Особенности**

      * Тип параметра определяется во время вызова метода.
      * Возможность комбинирования обобщённых методов с обобщёнными классами.

      **-** **Пример комбинирования:**

      ```java
      public class GenericPair<K, V> {
         private K key;
         private V value;

         public GenericPair(K key, V value) {
            this.key = key;
            this.value = value;
         }

         public <T> void printPair(T extraInfo) {
            System.out.println(key + " = " + value + ", Info: " + extraInfo);
         }
      }
      ```

      **-** **Использование:**

      ```java
      GenericPair<String, Integer> pair = new GenericPair<>("Age", 30);

      pair.printPair("Valid"); // Age = 30, Info: Valid
      ```

105. **Generics в Java. Типовые ограничения в Generics. Как задать ограничения на параметры типов с помощью ключевых слов extends и super? Примеры их использования для обеспечения гибкости и безопасности обобщений.**

      **-** **Ограничения на параметры типов**

      * Generics позволяют задавать ограничения для параметров типов с помощью ключевых слов:
         1. **extends** — ограничивает тип сверху (только подклассы указанного типа или сам тип).
         2. **super** — ограничивает тип снизу (только суперклассы указанного типа или сам тип).

      **-** **Примеры:**

      1. **Ограничение сверху (extends)**

      ```java
      public class GenericExample<T extends Number> {
         private T value;

         public GenericExample(T value) {
            this.value = value;
         }

         public double square() {
            return value.doubleValue() * value.doubleValue();
         }
      }
      ```

      * **Использование:**

      ```java
      GenericExample<Integer> intExample = new GenericExample<>(5);

      System.out.println(intExample.square()); // 25.0

      GenericExample<Double> doubleExample = new GenericExample<>(3.5);

      System.out.println(doubleExample.square()); // 12.25
      ```

      2. **Ограничение снизу (super)**

      ```java
      public static <T> void addToList(List<? super Integer> list, T item) {
         if (item instanceof Integer) {
            list.add((Integer) item);
         }
      }
      ```

      * **Использование:**

      ```java
      List<Number> numberList = new ArrayList<>();

      addToList(numberList, 10);

      System.out.println(numberList); // [10]
      ```

106. **Обобщенные интерфейсы. Использование Generics для создания универсальных интерфейсов. Примеры реализации обобщенных интерфейсов и их применения в реальных задачах.**

      **-** **Обобщённые интерфейсы**

      * Generics позволяют создавать универсальные интерфейсы, которые могут быть параметризованы типами. Это делает интерфейсы гибкими и переиспользуемыми.

      **-** **Пример реализации:**

      ```java
      public interface Pair<K, V> {
         K getKey();
         V getValue();
      }

      class KeyValuePair<K, V> implements Pair<K, V> {
         private K key;
         private V value;

         public KeyValuePair(K key, V value) {
            this.key = key;
            this.value = value;
         }

         public K getKey() {
            return key;
         }

         public V getValue() {
            return value;
         }
      }
      ```

      **-** **Использование:**

      ```java
      Pair<String, Integer> pair = new KeyValuePair<>("Age", 30);

      System.out.println(pair.getKey() + " = " + pair.getValue()); // Age = 30
      ```

107. **Generics в Java. Подстановочные знаки (Wildcards). Как использовать ?, <? extends T> и <? super T> для работы с коллекциями? Примеры их применения.**

      **-** Подстановочные знаки (?, <? extends T>, <? super T>) позволяют работать с неизвестными типами.

      1. **? — любой тип:**<br>
         Подходит, если тип данных неважен.

      ```java
      public static void printList(List<?> list) {
         for (Object obj : list) {
            System.out.println(obj);
         }
      }
      ```

      2. **<? extends T> — тип T или его подклассы:**<br>
         Используется для чтения данных, но запись ограничена.

      ```java
      public static double sum(List<? extends Number> list) {
         double sum = 0.0;

         for (Number num : list) {
            sum += num.doubleValue();
         }

         return sum;
      }
      ```

      * **Использование:**

      ```java
      List<Integer> integers = Arrays.asList(1, 2, 3);

      System.out.println(sum(integers)); // 6.0
      ```

      3. **<? super T> — тип T или его суперклассы:**
         Используется для записи данных.

      ```java
      public static void addNumbers(List<? super Integer> list) {
         list.add(1);
         list.add(2);
      }
      ```

      * **Использование:**

      ```java
      List<Number> numbers = new ArrayList<>();

      addNumbers(numbers);

      System.out.println(numbers); // [1, 2]
      ```

108. **Generics в Java. Стирание типов (Type Erasure). Как информация о Generics удаляется во время компиляции? Примеры преобразования Generics в сырой тип.**

      **-** **Стирание типов (Type Erasure):**

      * Generics в Java реализованы через механизм стирания типов. Это означает, что информация о типах, используемых в Generics, удаляется во время компиляции.
      * В результате, в байт-коде JVM работает с объектами, используя их базовый тип (обычно Object) или ограничение (например, Number в <T extends Number>).

      **-** **Почему используется Type Erasure?**

      * Совместимость с версиями Java до Generics (Java 5).
      * Унификация байт-кода для всех параметров типов, что упрощает выполнение.

      **-** **Как происходит стирание типов?**

      * Если тип параметра не ограничен (<T>), он заменяется на Object.
      * Если используется ограничение (<T extends Number>), тип заменяется на это ограничение (Number).

      **-** **Пример преобразования Generics в сырой тип:**

      ```java
      public class Box<T> {
         private T value;

         public void setValue(T value) {
            this.value = value;
         }

         public T getValue() {
            return value;
         }
      }
      ```

      * После стирания типов, класс выглядит так:

      ```java
      public class Box {
         private Object value;

         public void setValue(Object value) {
            this.value = value;
         }

         public Object getValue() {
            return value;
         }
      }
      ```

      **-** **Пример использования сырого типа:**

      ```java
      Box rawBox = new Box(); // Сырой тип

      rawBox.setValue("Hello"); // Можно установить любой тип

      String value = (String) rawBox.getValue(); // Приведение типов вручную
      ```

      **-** **Риски сырого типа:**

      * Потеря типобезопасности.
      * Возможность возникновения ошибок во время выполнения (например, ClassCastException).

109. **Коллекции в Java. Понятие коллекций как структур данных для хранения объектов. Основные интерфейсы и классы в Java Collections Framework (JCF). Примеры использования коллекций для хранения и обработки данных.**

      **-** Коллекции — это структуры данных, которые используются для хранения, управления и обработки наборов объектов. Коллекции упрощают управление данными, предоставляя готовые реализации для работы с массивами, списками, множествами, очередями и ассоциативными массивами.

      **-** **Java Collections Framework (JCF)**

      * Java Collections Framework — набор интерфейсов, классов и алгоритмов для работы с коллекциями.

      **-** **Основные интерфейсы и классы JCF:**

      1. **Collection** — базовый интерфейс для всех коллекций.
      2. **List** — упорядоченная коллекция, допускающая дубликаты:
         * Классы: ArrayList, LinkedList, Vector.
      3. **Set** — коллекция, не допускающая дубликатов:
         * Классы: HashSet, LinkedHashSet, TreeSet.
      4. **Map** — коллекция пар ключ-значение:
         * Классы: HashMap, TreeMap, LinkedHashMap.
      5. **Queue** — коллекция для работы с очередями:
         * Классы: PriorityQueue, ArrayDeque.

      **-** **Примеры использования:**

      1. **Работа со списком:**

      ```java
      List<String> list = new ArrayList<>();

      list.add("Apple");
      list.add("Banana");
      list.add("Apple"); // допускаются дубликаты

      System.out.println(list); // [Apple, Banana, Apple]
      ```

      2. **Работа с множеством:**

      ```java
      Set<String> set = new HashSet<>();

      set.add("Apple");
      set.add("Banana");
      set.add("Apple"); // дубликаты игнорируются

      System.out.println(set); // [Apple, Banana]
      ```

      3. **Работа с картой:**

      ```java
      Map<String, Integer> map = new HashMap<>();

      map.put("Apple", 1);
      map.put("Banana", 2);

      System.out.println(map.get("Apple")); // 1
      ```

110. **Иерархия коллекций. Структура иерархии коллекций в Java. Основные интерфейсы (Collection, List, Set, Map) и их ключевые особенности. Примеры реализации различных типов коллекций.**

      **-** **Основные интерфейсы и структура иерархии коллекций:**

      1. **Collection (java.util.Collection):**
         * Родительский интерфейс для List, Set, Queue.
         * Основные методы: add(), remove(), size(), isEmpty().
      2. **List:**
         * Упорядоченная коллекция (индексируемая).
         * Реализации: ArrayList, LinkedList, Vector.
      3. **Set:**
         * Не допускает дубликатов.
         * Реализации: HashSet, LinkedHashSet, TreeSet.
      4. **Map (java.util.Map):**
         * Хранит данные в виде пар "ключ-значение".
         * Реализации: HashMap, TreeMap, LinkedHashMap.
      5. **Queue:**
         * Очередь для работы с элементами в порядке FIFO или приоритетном.
         * Реализации: LinkedList, PriorityQueue, ArrayDeque.

      **-** **Примеры реализации:**

      1. **ArrayList:**

      ```java
      List<Integer> numbers = new ArrayList<>();

      numbers.add(10);
      numbers.add(20);

      System.out.println(numbers); // [10, 20]
      ```

      2. **HashSet:**

      ```java
      Set<String> set = new HashSet<>();

      set.add("Java");
      set.add("Python");

      System.out.println(set); // [Java, Python]
      ```

      3. **HashMap:**

      ```java
      Map<String, String> map = new HashMap<>();

      map.put("Key1", "Value1");

      System.out.println(map); // {Key1=Value1}
      ```

111. **LinkedList в Java. Особенности класса LinkedList как реализации интерфейса List. Преимущества использования.** 

      **-** **Особенности LinkedList:**

      1. **Двусвязный список.**
      2. Реализует интерфейсы List, Deque, Queue.
      3. Быстрая вставка и удаление элементов.
      4. Медленный доступ по индексу.

      **-** **Преимущества:**

      * Эффективен для частой вставки/удаления элементов.
      * Может использоваться как стек, очередь или двухсторонняя очередь.

      **Пример:**

      ```java
      LinkedList<String> linkedList = new LinkedList<>();

      linkedList.add("Java");
      linkedList.addFirst("Python");
      linkedList.addLast("C++");

      System.out.println(linkedList); // [Python, Java, C++]
      ```

112. **Коллекции в Java. Понятие коллекций как структур данных для хранения объектов. Основные цели использования коллекций. Роль Iterable в Java Collections Framework.** 

      **-** **Роль интерфейса Iterable:**

      * Базовый интерфейс для всех коллекций.
      * Обеспечивает возможность перебора элементов с использованием цикла for-each.

      **-** **Основные цели использования коллекций:**

      1. Упрощение хранения и обработки данных.
      2. Повышение читаемости и типобезопасности кода.
      3. Унификация работы с разными структурами данных.

      **Пример:**

      ```java
      List<String> list = new ArrayList<>();

      list.add("A");
      list.add("B");

      for (String s : list) {
         System.out.println(s);
      }
      ```

113. **Коллекции в Java. Реализации List - ArrayList. Особенности функционирования ArrayList. Пример использования ArrayList.**

      **-** **Особенности ArrayList**

      1. **Основан на массиве.**
         * ArrayList использует внутренний массив для хранения элементов.
         * При переполнении массива его размер автоматически увеличивается (обычно на 50%).
      2. **Динамическое изменение размера.**
         * Размер массива изменяется автоматически при добавлении элементов.
      3. **Доступ по индексу.**
         * Предоставляет быстрый доступ к элементам (сложность O(1)).
      4. **Медленные операции вставки и удаления.**
         * При добавлении/удалении элемента в середине списка требуется сдвигать оставшиеся элементы.

      **-** **Пример использования:**

      ```java
      import java.util.ArrayList;

      public class Main {
         public static void main(String[] args) {
            ArrayList<String> fruits = new ArrayList<>();

            // Добавление элементов
            fruits.add("Apple");
            fruits.add("Banana");
            fruits.add("Cherry");

            // Доступ по индексу
            System.out.println(fruits.get(1)); // Banana

            // Удаление элемента
            fruits.remove(0);
            System.out.println(fruits); // [Banana, Cherry]
         }
      }
      ```

114. **Коллекции в Java. Создание Generic Collection в Java. Преимущества данного подхода. Примеры.** 

      **-** **Generics и коллекции**

      * Generics позволяют создавать коллекции, способные работать с любыми типами данных, обеспечивая при этом типобезопасность.

      **-** **Преимущества использования Generics:**

      1. **Типобезопасность:**
         * Исключает необходимость приведения типов.
      2. **Повышение читаемости и надежности кода.**
      3. **Проверка типов на этапе компиляции.**
         * Ошибки работы с типами обнаруживаются раньше.

      **-** **Пример создания Generic Collection:**

      ```java
      import java.util.ArrayList;

      public class Main {
         public static void main(String[] args) {
            // Создание коллекции с типом String
            ArrayList<String> names = new ArrayList<>();

            names.add("Alice");
            names.add("Bob");
            // names.add(10); // Ошибка компиляции

            for (String name : names) {
               System.out.println(name);
            }
         }
      }
      ```

115. **Коллекции и Generics. Использование Generics для типобезопасности в коллекциях. Примеры создания типизированных списков и множеств.**

      **-** **Преимущества использования типизированных коллекций:**

      1. **Нет необходимости приведения типов:**
         * Исключает ошибки приведения типов.
      2. **Улучшенная читаемость кода.**
      3. **Обеспечение универсальности кода.**

      **-** **Примеры:**

      1. **Типизированный список:**

      ```java
      import java.util.ArrayList;

      public class Main {
         public static void main(String[] args) {
            ArrayList<Integer> numbers = new ArrayList<>();

            numbers.add(1);
            numbers.add(2);
            // numbers.add("Three"); // Ошибка компиляции

            for (Integer num : numbers) {
               System.out.println(num);
            }
         }
      }
      ```

      2. **Типизированное множество:**

      ```java
      import java.util.HashSet;

      public class Main {
         public static void main(String[] args) {
            HashSet<String> set = new HashSet<>();

            set.add("Java");
            set.add("Python");
            set.add("Java"); // Дубликат не добавляется

            for (String s : set) {
               System.out.println(s);
            }
         }
      }
      ```

116. **ArrayList в Java. Понятие ArrayList как реализации интерфейса List. Основные методы (add, get, remove) для работы со списками. Примеры добавления, удаления и доступа к элементам.**

      **-** ArrayList — это класс из пакета java.util, реализующий интерфейс List. Он представляет собой динамический массив, который изменяет свой размер при добавлении новых элементов.

      **-** **Основные методы:**

      1. **Добавление элементов:**
         1. add(E e) — добавляет элемент в конец списка.
         2. add(int index, E e) — добавляет элемент на указанную позицию.
      2. **Получение элементов:**
         1. get(int index) — возвращает элемент по индексу.
      3. **Удаление элементов:**
         1. remove(int index) — удаляет элемент по индексу.
         2. remove(Object o) — удаляет первый найденный элемент.
      4. **Другие методы:**
         1. size() — возвращает количество элементов в списке.
         2. isEmpty() — проверяет, пуст ли список.

      **-** **Пример использования:**

      ```java
      import java.util.ArrayList;

      public class Main {
         public static void main(String[] args) {
            ArrayList<String> cities = new ArrayList<>();

            // Добавление элементов
            cities.add("New York");
            cities.add("Los Angeles");
            cities.add("Chicago");

            // Получение элемента
            System.out.println(cities.get(1)); // Los Angeles

            // Удаление элемента
            cities.remove(0);
            System.out.println(cities); // [Los Angeles, Chicago]

            // Размер списка
            System.out.println("Size: " + cities.size()); // 2
         }
      }
      ```

